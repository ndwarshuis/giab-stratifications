---
title: "v3.1-stratifications Validation"
output:
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 4
    toc_float: true
    df_print: paged
author: Jenny McDaniel
date: "`r format(Sys.time(), '%d %B, %Y')`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.width=25, fig.height=25, fig_caption=TRUE)
```

### Purpose

This markdown will be used to validate stratification BED files for the
v3.1-stratification release. Validation includes:

1. Confirm expected chromosomes are covered and coverage of individual
   chromosomes is as expected
2. Confirm coverage between GRCh37 and GRCh38 is similar or as expected.
3. Confirm coverage of CHM13 seems reasonable

<!-- #### Script inputs relative to working directory -->
<!-- 1. Candidate stratification files that have been post-processed or carried over located in -->
<!--     - v3.1-files-for-validation pulled from v3.1-candidate-release-files -->
<!-- 2. csv file with stratification file info located in working directory -->
<!-- 3. Chromosome BED files for calculating coverage -->
<!--     - genome-bed-files/GRCh37_1-22XY_sorted_NoNs_NoPSAY_merged.genome.bed -->
<!--     - genome-bed-files/GRCh38_1-22XY_sorted_NoNs_NoPSAY_merged.genome.bed -->
<!--     - genoem-bed-files/CHM13v2.0_1-22XY_sorted.genome.bed -->
    
### Coverage Plots

```{r}
library(tidyverse)
library(here)

df_strats <- snakemake@input$strats %>%
  set_names() %>%
  map(read_tsv, 
      comment = "#",
      col_types = "cdd",
      col_names = c("chrom","start","end")) %>%
  list_rbind(names_to = "path") %>%
  mutate(strat_type = basename(dirname(path)),
         strat_filename = basename(path),
         genome = str_extract(strat_filename, "^[^_]_(HG[0-9]+)_.bed.gz", 1),
         reference = str_extract(strat_filename, "^([^_])_.*.bed.gz", 1),
         strat_level =
           if_else(is.na(genome),
                   str_extract(strat_filename, "^[^_]_(.*).bed.gz", 1),
                   str_extract(strat_filename, "^[^_]_HG[0-9]+_(.*).bed.gz", 1)),
         region_size = end - start) %>%
  select(-path)

## stratfile_all_summary <- here("v3.1-stratfications-info.csv") %>%
##   read.csv(header = TRUE, na.strings = TRUE) 

## strat38_summary <- here("v3.1-stratfications-info.csv") %>% 
##   read.csv(header = TRUE, na.strings = TRUE)  %>% 
##   filter(reference =="GRCh38") 

## beds38_df_with_levels <- left_join(beds38_df, strat38_summary) 

## Chromosome Presence/ Absence  #####################################
###########################################################################
## vector of chromosomes we expect to have

chroms <- c(1:22, "X", "Y")
expected_chroms <- factor(c(paste0("chr", chroms), chroms),
                          levels = c(paste0("chr", chroms), chroms))

## dataframes with Expected and Unexpected chroms for plotting
expected_chroms_38 <- df_strats %>%
  filter(chrom %in% expected_chroms)
unexpected_chroms_38 <- df_strats %>%
  filter(!chrom %in% expected_chroms)

## Get Chromosome Sizes -- alternate method using UCSC Ns from Aaron script
###########################################################################
#read in genome BEDs that have had Ns and PSA regions for Y removed

df_sizes <- read_tsv(snakemake@input$gaps,
                    col_names = c("chrom", "start", "end"),
                    col_types = "cii")
  mutate(region_size = end - start) %>%
  group_by(chrom) %>%
  summarise(nonN_ref_len = sum(region_size))

## Create Dataframes for plotting chromosome sizes ########################
###########################################################################

## Add column to table of 37 and 38  to calculate region sizes

#Sum of all regions by chromosome

chrom_region_sizes_38stratifications <- df_strats %>%
  group_by(strat_filename, chrom) %>%
  summarise(total_region = sum(region_size))

## combine ref and strat region size dataframes
## total_region=sum of stratification chrom regions size (use for plots),
## Non_N=ref chrom size w/o Ns (use for plots), len=total length of chrom regions

stratANDref_38chromsizes <- left_join(chrom_region_sizes_38stratifications,
                                      chromsizes_38)
stratANDref_38chromsizes <- add_column(stratANDref_38chromsizes,
                                       "reference" = "GRCh38")

## Create table with all stratification and reference chrom sizes and
## stratification types
## full <- full_join(stratANDref_37chromsizes, stratANDref_38chromsizes)
## fuller <- full_join(full, stratANDref_13chromsizes)

## summary_for_plots <- fuller %>% left_join(stratfile_all_summary)
## summary_for_plots <- summary_for_plots  %>% mutate(coverage = total_region/nonN_ref_len)
## chrom_order <- paste0("chr",c(1:22, "X","Y"))
## summary_for_plots$chrom <- factor(summary_for_plots$chrom, levels = c(chrom_order))

## Coverage Plots #########################################################
###########################################################################

coverage_plot <- function(strat_type_df, strat_type){
    ggplot(strat_type_df,
         aes(x=chrom, y=coverage, group = reference)) +
    geom_col(aes(fill = reference), position = "dodge") +
    facet_grid(scales = "free_y", stratification_level ~ .) +
    theme(legend.position = "top",
          text = element_text(size=30),
          axis.text.x = element_text(angle=90),
          strip.text.y = element_text(angle = 0),
          panel.spacing.y = unit(2, "lines"))
}

#Generate plots for desired stratification types (code below)
```

#### Check for stratification files for unexpected chromosomes

Expected chromosomes are chr1-22, X and Y.

```{r, message=FALSE, warning=FALSE}
#if unexpected DF rows are empty, report no unexpected chroms found
if ((dim(unexpected_chroms_38)[1]) == 0) {
  print("No unexpected chromosomes found for GRCh38 stratifications.")
}else{
  print("Unexpected chromosomes found for GRCh38")
  unexpected_chroms_38
}

#if unexpected DF rows are empty, report no unexpected chroms found
## if ((dim(unexpected_chroms_13)[1]) == 0) {
##   print("No unexpected chromosomes found for CHM13 stratifications.")
## }else{
##   print("Unexpected chromosomes found for CHM13")
##   unexpected_chroms_13
## }

## if ((dim(unexpected_chroms_37)[1]) == 0) {
##   print("No unexpected chromosomes found for GRCh37 stratifications.")
## }else{
##   print("Unexpected chromosomes found for GRCh37")
##   unexpected_chroms_37
## }
```

#### Low Complexity

Regions with different types and sizes of low complexity sequence (e.g.,
homopolymers, STRs, VNTRs, other locally repetitive sequences).

```{r, message=FALSE, warning=FALSE, fig.height=40, fig.width=25}
# summary_for_plots %>%
#   filter(stratification_type == "LowComplexity") %>%
#   coverage_plot(strat_type = "LowComplexity") 
LowComplexity <-filter(summary_for_plots, stratification_type == "LowComplexity")
  ggplot(LowComplexity, aes(x=chrom, y=coverage, group = reference)) +
  geom_col(aes(fill = reference), position = "dodge") +
    facet_grid(scales = "free", stratification_level ~ .) +
    theme(legend.position = "top",
          text = element_text(size=30),
          axis.text.x = element_text(angle=90),
          strip.text.y = element_text(angle = 0))
```

#### Functional Technically Difficult

Different functional, or potentially functional, regions that are also likely to
be technically difficult to sequence.

```{r, message=FALSE, warning=FALSE}
summary_for_plots %>%
  filter(stratification_type == "FunctionalTechnicallyDifficult") %>%
  coverage_plot(strat_type = "FunctionalTechnicallyDifficult")
```

<!-- #### Genome Specific -->
<!-- ```{r, message=FALSE, warning=FALSE} -->
<!-- GSpecific <-filter(summary_for_plots, stratification_type == "GenomeSpecific") -->
<!-- ggplot(GSpecific, aes(x=chrom, y=coverage, group = reference)) + -->
<!--   geom_col(aes(fill = reference ), position = "dodge") + -->
<!--   facet_grid(stratification_level ~ genome, scales = "free") + -->
<!--       theme(legend.position = "top", -->
<!--           text = element_text(size=30), -->
<!--           axis.text.x = element_text(angle=90), -->
<!--           strip.text.y = element_text(angle = 0), -->
<!--           panel.spacing.y = unit(2, "lines")) -->
<!-- ``` -->
#### Genome Specific (benchmark v4.2.1)

Difficult regions due to potentially difficult variation in the NIST/GIAB
sample, including (1) regions containing putative compound heterozygous
variants, (2) regions containing multiple variants within 50 bp of each other,
(3) regions with potential structural variation and copy number variation.

```{r, message=FALSE, warning=FALSE, fig.height=30, fig.width=25}
GSpecific <-filter(summary_for_plots, stratification_type == "GenomeSpecific")
ggplot(GSpecific, aes(x=chrom, y=coverage, group = reference)) +
  geom_col(aes(fill = reference ), position = "dodge") +
  facet_grid(stratification_level ~ genome, scales = "free") +
  theme(axis.text.x = element_text(angle = 90),
        legend.position = "top",
        strip.text.y = element_text(angle = 0))
```

#### Functional Regions

Regions to stratify variants inside and outside of coding regions.

```{r, message=FALSE, warning=FALSE}
summary_for_plots %>%
  filter(stratification_type == "FunctionalRegions") %>%
  coverage_plot(strat_type = "FunctionalRegions")
```

#### GC Content

Regions with different ranges(%) of GC content.

```{r, message=FALSE, warning=FALSE}
summary_for_plots %>%
  filter(stratification_type == "GCcontent") %>%
  coverage_plot(strat_type = "GCcontent")
```

#### Mappability

Regions where short read mappability can be challenging.

```{r, message=FALSE, warning=FALSE}
summary_for_plots %>%
  filter(stratification_type == "mappability") %>%
  coverage_plot(strat_type = "mappability")
```

#### Other Difficult

Highly variable regions like the VDJ and MHC, near gaps in the reference, or errors in the reference.

```{r, message=FALSE, warning=FALSE, fig.height=30, fig.width=22}
summary_for_plots %>%
  filter(stratification_type == "OtherDifficult") %>%
  coverage_plot(strat_type = "OtherDifficult")
```

#### Segmental Duplications

Regions with segmental duplications or regions with non-trivial self-chain alignments.

```{r, message=FALSE, warning=FALSE}
summary_for_plots %>%
  filter(stratification_type == "SegmentalDuplications") %>%
  coverage_plot(strat_type = "SegmentalDuplications")
```

#### Union

Regions with different general types of difficult regions or any type of difficult region or complex variant. For example, performance can be measured in just the "easy" regions of the genome.

```{r, message=FALSE, warning=FALSE}
summary_for_plots %>%
  filter(stratification_type == "Union") %>%
  coverage_plot(strat_type = "Union")
```

#### Ancestry

Regions with inferred patterns of local ancestry in GRCh38.

```{r, message=FALSE, warning=FALSE}
summary_for_plots %>%
  filter(stratification_type == "ancestry") %>%
  coverage_plot(strat_type = "ancestry")
```

#### XY

Regions in chromosomes X and Y

```{r, message=FALSE, warning=FALSE}
summary_for_plots %>%
  filter(stratification_type == "XY") %>%
  coverage_plot(strat_type = "XY")
```

### Session Information

#### System Information

```{r}
library(sessioninfo)
sessioninfo::platform_info()
```

#### Package Versions

```{r}
# TODO probably not necessary
sessioninfo::package_info() %>%
    filter(attached == TRUE) %>%
    select(package, loadedversion, date, source)
<!-- knitr::kable(booktabs = TRUE, row.names = FALSE) -->
```
