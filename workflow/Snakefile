from pathlib import Path
from snakemake.utils import min_version

min_version("7.20")


# required to get snakemake to properly depickle a pydantic model
sys.path.extend(["./workflow/scripts/python"])
from common.config import GiabStrats

config = GiabStrats.parse_obj(config)


def expand_final_to_src(paths, wildcards, bla=None):
    # print((wildcards.ref_final_key, bla))
    return expand(paths, allow_missing=True, ref_src_key=wildcards.ref_final_key)


def read_checkpoint(rulename, wildcards):
    r = getattr(checkpoints, rulename)
    c = r.get(
        ref_key=strip_refkey(wildcards.ref_final_key),
        build_key=wildcards.build_key,
    )
    with c.output[0].open() as f:
        return json.load(f)


def read_named_checkpoint(rulename, name, wildcards):
    # TODO not DRY
    r = getattr(checkpoints, rulename)
    c = r.get(
        ref_key=strip_refkey(wildcards.ref_final_key),
        build_key=wildcards.build_key,
    )
    with c.output[name][0].open() as f:
        return json.load(f)


def bed_src_inputs(pathlist, f, wildcards):
    rk = wildcards.ref_key
    rsks = config.refkey_to_bed_refsrckey(f, wildcards.ref_key)
    return expand(pathlist, ref_src_key=rsks)


def to_bed_src(f, wildcards):
    return config.refsrckey_to_bed_src(f, wildcards.ref_src_key)


# TODO change the "ref_key" name to something else that actually reflects the
# fact it may/may not have a haplotype tagged on the end of it and doesn't
# correspond to the key in the config corresponding to each reference)
wildcard_constraints:
    # permit alphanumerics and dashes only, underscores will be used for
    # separation in filepaths; this convention makes it impossible for
    # wildcards to be ambiguous
    ref_key="[A-Za-z0-9-]+",
    build_key="[A-Za-z0-9-]+",
    # separate ref key for downloading (which may or may not follow the
    # cardinality of the target reference)
    ref_src_key="[A-Za-z0-9-]+(\.hap(1|2))?",
    ref_final_key="[A-Za-z0-9-]+(\.hap(1|2))?",
    # this appears way too often, so define constraint here
    sex_chr="[XY]",


include: "rules/repseq.smk"
include: "rules/ref.smk"
include: "rules/xy.smk"
include: "rules/low_complexity.smk"
include: "rules/gc.smk"
include: "rules/telomeres.smk"
include: "rules/functional.smk"
include: "rules/segdups.smk"
include: "rules/other.smk"
include: "rules/mappability.smk"
include: "rules/otherdifficult.smk"
include: "rules/union.smk"
include: "rules/postprocess.smk"


# rule to download stuff to make testing pipeline faster (this only includes
# the big stuff, like .fa files and large bed files)
rule all_resources:
    input:
        expand(rules.download_ref.output, ref_src_key=config.all_ref_refsrckeys),
        expand(rules.download_gaps.output, ref_src_key=config.all_refkey_gap),
        expand(rules.download_rmsk.output, ref_src_key=config.all_refkey_rmsk),
        expand(rules.download_trf.output, ref_src_key=config.all_refkey_trf),
        expand(rules.download_censat.output, ref_src_key=config.all_refkey_censat),
        expand(rules.download_superdups.output, ref_src_key=config.all_refkey_segdups),
        expand(rules.download_ftbl.output, ref_src_key=config.all_refkey_ftbl),
        expand(rules.download_gff.output, ref_src_key=config.all_refkey_gff),
        # TODO not DRY
        expand(
            rules.download_bench_vcf.output,
            ref_src_key=(t := unzip(config.all_buildkey_bench_vcf))[0],
            build_key=t[1],
        ),
        expand(
            rules.download_bench_bed.output,
            ref_src_key=(t := unzip(config.all_buildkey_bench_bed))[0],
            build_key=t[1],
        ),
        expand(
            rules.download_query_vcf.output,
            ref_src_key=(t := unzip(config.all_buildkey_query_vcf))[0],
            build_key=t[1],
        ),


rule all:
    input:
        rules.checksum_everything.output,
