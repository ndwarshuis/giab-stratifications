from pathlib import Path
from snakemake.utils import min_version

# required to get snakemake to properly depickle a pydantic model
sys.path.extend(["./workflow/scripts/python"])
from common.config import GiabStrats
from common.functional import unzip2

min_version("7.20")

config = GiabStrats.parse_obj(config)


def expand_final_to_src(paths, wildcards):
    return expand(paths, allow_missing=True, ref_src_key=wildcards.ref_final_key)


def read_checkpoint(rulename, wildcards, other=[]):
    r = getattr(checkpoints, rulename)
    rk, _ = parse_final_refkey(wildcards.ref_final_key)
    c = r.get(
        ref_key=rk,
        build_key=wildcards.build_key,
        **{k: wildcards[k] for k in other},
    )
    with c.output[0].open() as f:
        return json.load(f)


def read_named_checkpoint(rulename, name, wildcards):
    # TODO not DRY
    r = getattr(checkpoints, rulename)
    rk, _ = parse_final_refkey(wildcards.ref_final_key)
    c = r.get(ref_key=rk, build_key=wildcards.build_key)
    # TODO isn't there supposed to be a [0] after [name]?
    with c.output[name].open() as f:
        return json.load(f)


def bed_src_inputs(pathlist, f, wildcards):
    rk = wildcards.ref_key
    rsks = config.refkey_to_bed_refsrckeys(f, rk)
    return expand(pathlist, ref_src_key=rsks)


def bed_src_bd_inputs(pathlist, f, wildcards):
    rk = wildcards.ref_key
    bk = wildcards.build_key
    rsks = config.buildkey_to_bed_refsrckeys(f, rk, bk)
    return expand(pathlist, allow_missing=True, ref_src_key=rsks, build_key=bk)


def to_bed_src(f, wildcards):
    return config.refsrckey_to_bed_src(f, wildcards.ref_src_key)


# TODO change the "ref_key" name to something else that actually reflects the
# fact it may/may not have a haplotype tagged on the end of it and doesn't
# correspond to the key in the config corresponding to each reference)
wildcard_constraints:
    # permit alphanumerics and dashes only, underscores will be used for
    # separation in filepaths; this convention makes it impossible for
    # wildcards to be ambiguous
    ref_key="[A-Za-z0-9-]+",
    build_key="[A-Za-z0-9-]+",
    # separate ref key for downloading (which may or may not follow the
    # cardinality of the target reference)
    ref_src_key="[A-Za-z0-9-]+(\.hap(1|2))?",
    ref_final_key="[A-Za-z0-9-]+(\.hap(1|2))?",
    # this appears way too often, so define constraint here
    sex_chr="[XY]",


include: "rules/repseq.smk"
include: "rules/ref.smk"
include: "rules/xy.smk"
include: "rules/low_complexity.smk"
include: "rules/gc.smk"
include: "rules/telomeres.smk"
include: "rules/functional.smk"
include: "rules/segdups.smk"
include: "rules/other.smk"
include: "rules/mappability.smk"
include: "rules/otherdifficult.smk"
include: "rules/union.smk"
include: "rules/postprocess.smk"


# rule to download stuff to make testing pipeline faster (this only includes
# the big stuff, like .fa files and large bed files)
rule all_resources:
    input:
        expand(rules.download_ref.output, ref_src_key=config.all_ref_refsrckeys),
        expand(rules.download_gaps.output, ref_src_key=config.all_refkey_gap),
        expand(rules.download_rmsk.output, ref_src_key=config.all_refkey_rmsk),
        expand(rules.download_trf.output, ref_src_key=config.all_refkey_trf),
        expand(rules.download_censat.output, ref_src_key=config.all_refkey_censat),
        expand(rules.download_superdups.output, ref_src_key=config.all_refkey_segdups),
        expand(rules.download_ftbl.output, ref_src_key=config.all_refkey_ftbl),
        expand(rules.download_gff.output, ref_src_key=config.all_refkey_gff),
        # TODO this function is misleading
        expand(
            rules.download_bench_vcf.output
            + rules.download_bench_bed.output
            + rules.download_query_vcf.output,
            ref_src_key=(t := unzip2(config.all_buildkey_bench_vcf))[0],
            build_key=t[1],
        ),


rule all:
    input:
        rules.checksum_everything.output,
